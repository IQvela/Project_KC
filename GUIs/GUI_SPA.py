# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Point_SPA_ReadData.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.   

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox
#import PyQt5
#import tkinter as tk
import pandas as pd
import numpy as np
import datetime


class Ui_MainWindow(object):
    column_names={"Sheets":(0,"Sheets"),"Date":(1,"(YYYY-MM-DD)"),"Time":(2,"(HH:MM:SS)"),"BialR":(3,"Bial/Repet."),"GPX":(4,"G Label")}
    
    def __init__(self):
        self.MainWindow=QtWidgets.QMainWindow()
        self.finish_window=False
    
    def setupUi(self):
        self.MainWindow.setObjectName("MainWindow")
        self.MainWindow.resize(700, 350)
        self.centralwidget = QtWidgets.QWidget(self.MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.Label1_Title = QtWidgets.QLabel(self.centralwidget)
        self.Label1_Title.setGeometry(QtCore.QRect(50, 20, 321, 31))
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.Label1_Title.setFont(font)
        self.Label1_Title.setObjectName("Label1_Title")
        self.Label2_Description = QtWidgets.QLabel(self.centralwidget)
        self.Label2_Description.setGeometry(QtCore.QRect(50, 50, 341, 31))#(ax,ay,aw,ah)
        self.Label2_Description.setObjectName("Label2_Description")
        
        self.GPX_filled=0 #samples filled
        self.Label3_GPX=QtWidgets.QLabel(self.centralwidget)
        self.Label3_GPX.setGeometry(QtCore.QRect(450,65,200,20))
        self.Label3_GPX.setText("GPX samples filled: {}".format(self.GPX_filled))
        
        self.Table_Sheets = QtWidgets.QTableWidget(self.centralwidget)
        self.Table_Sheets.setGeometry(QtCore.QRect(50, 90, 600, 192))
        self.Table_Sheets.setMaximumSize(QtCore.QSize(600, 16777215))
        self.Table_Sheets.setShowGrid(True)
        self.Table_Sheets.setRowCount(1)
        self.Table_Sheets.setObjectName("Table_Sheets")
        self.Table_Sheets.setColumnCount(5)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setItem(0, 0, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setItem(0, 1, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setItem(0, 2, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setItem(0, 3, item)
        item = QtWidgets.QTableWidgetItem()
        self.Table_Sheets.setItem(0, 4, item)
        self.Table_Sheets.horizontalHeader().setCascadingSectionResizes(False)
        self.Table_Sheets.horizontalHeader().setDefaultSectionSize(100)
        
        #ReadTable Button
        self.Button_ReadTable = QtWidgets.QPushButton(self.centralwidget)
        self.Button_ReadTable.setGeometry(QtCore.QRect(120, 300, 91, 31))
        #self.Button1.setObjectName("Button1")
        self.Button_ReadTable.setText("Read Table")
        self.Button_ReadTable.clicked.connect(self.read_table)
        
        #Fill Fields Button
        self.Button_FillFields=QtWidgets.QPushButton(self.centralwidget)
        self.Button_FillFields.setGeometry(QtCore.QRect(400,300,91,31))#(ax=400,ay=300, aw=91, ah=31)
        self.Button_FillFields.setText("Fill Fields")
        self.Button_FillFields.clicked.connect(self.fill_fields)
        
        #Cancel Button
        self.Button_Cancel = QtWidgets.QPushButton(self.centralwidget)
        self.Button_Cancel.setGeometry(QtCore.QRect(260, 300, 91, 31))
        #self.Button2.setObjectName("Button2")
        self.Button_Cancel.setText("Cancel")
        self.Button_Cancel.clicked.connect(self.cancel_window)
        
        #change the collection date button
        self.Button_ChangeDate=QtWidgets.QPushButton(self.centralwidget)
        self.Button_ChangeDate.setGeometry(QtCore.QRect(570,45,80,20))
        self.Button_ChangeDate.setText("Change Date")
        self.Button_ChangeDate.clicked.connect(self.change_date)
        
        #Entry box  of the date
        self.inputdate=QtWidgets.QLineEdit(self.centralwidget)
        self.inputdate.setGeometry(QtCore.QRect(580,20,70,20))

        #label of the data collection date
        self.label_date=QtWidgets.QLabel(self.centralwidget)
        self.label_date.setGeometry(QtCore.QRect(480,20,90,20))  
        self.label_date.setText("Data collected:")
        
        self.MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self.MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 623, 21))
        self.menubar.setObjectName("menubar")
        self.MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(self.MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi()#self.MainWindow)
        QtCore.QMetaObject.connectSlotsByName(self.MainWindow)

    def retranslateUi(self):
        #cnum=
        _translate = QtCore.QCoreApplication.translate
        self.MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.Label1_Title.setText(_translate("MainWindow", "List of Sheets in SPA excel file"))
        self.Label2_Description.setText(_translate("MainWindow", "The date corresponds with the SPA collection not the characterization\n"
""))
        self.Table_Sheets.setSortingEnabled(False)
        
        for k,v in Ui_MainWindow.column_names.items():            
            item = self.Table_Sheets.horizontalHeaderItem(v[0])
            item.setText(_translate("MainWindow", v[1]))
        
        self.Table_Sheets.setColumnWidth(0, 200)
        self.Table_Sheets.setColumnWidth(3, 80)
        self.Table_Sheets.setColumnWidth(4, 70)
        #item.
        __sortingEnabled = self.Table_Sheets.isSortingEnabled()
        self.Table_Sheets.setSortingEnabled(False)

        self.Table_Sheets.setSortingEnabled(__sortingEnabled)



    def read_file(self,fname):
        # _translate = QtCore.QCoreApplication.translate
        excel_file=pd.ExcelFile(fname)
        sheets=excel_file.sheet_names        

        sheet_Date=str(fname.split("_")[-1].split(".")[0])
        if len(sheet_Date)==6:
            sheet_Date="20"+sheet_Date
        elif len(sheet_Date)!=6 or len(sheet_Date)!=8:
            #print("Error, the date written at the end of the file´s title has no date format YYYYMMDD or YYMMDD. cf. {}".format(sheet_Date))   
            Message_popup("Error","Format Error, the date written at the end of the file´s title has no date format YYYYMMDD or YYMMDD. cf. {}".format(sheet_Date)) 
        self.measure_Date=sheet_Date[:4]+"-"+sheet_Date[4:6]+"-"+sheet_Date[6:8] #date where the data was collected
        
        self.inputdate.setText(self.measure_Date)
        self.get_sheets(sheets)
        #return sheets
        
    def get_sheets(self,sheets_list):
        cnum=Ui_MainWindow.column_names
        # _translate = QtCore.QCoreApplication.translate
        #excel_file=pd.ExcelFile(fname)
        sheets=sheets_list#excel_file.sheet_names
        self.Table_Sheets.setRowCount(len(sheets))
        for r in range(0,self.Table_Sheets.rowCount()):
            for c in range(0,self.Table_Sheets.columnCount()):
                item=QtWidgets.QTableWidgetItem()
                self.Table_Sheets.setItem(r,c,item)
                
        #Extracting and written in the table the F/C and G values of the sheet names
        for i in range(0,len(sheets)):
            item=self.Table_Sheets.item(i,cnum["Sheets"][0])
            item.setText(sheets[i])
            
            sheet_name_splitted=sheets[i].split("_")
            item_FR=self.Table_Sheets.item(i,cnum["BialR"][0]) #F/C_Repetition Value (3 repetitions are taken by the GC of the bial(F or C) per each sample)
            item_GPX=self.Table_Sheets.item(i,cnum["GPX"][0]) #G_Point_Sample Value (4 samples are collected per point)
              
            item_date=self.Table_Sheets.item(i,cnum["Date"][0])
            
            if sheet_name_splitted[-4].find("G")!=-1: #-1 means that there is no G               
                item_FR.setText(sheet_name_splitted[-3]+"_"+sheet_name_splitted[-1])                
                item_GPX.setText(sheet_name_splitted[-4])
                item_date.setText(self.measure_Date)#sheet_Date1)#"2019-01-23")#sheet_date)        
            else:
                item_FR.setText("N/A")                
                item_GPX.setText("N/A")  
                item_date.setText("N/A")
            
    def change_date(self):
        cnum=Ui_MainWindow.column_names
        #get from the entrybox the date
        self.measure_Date=self.inputdate.text()        
        for i in range(0,self.Table_Sheets.rowCount()):  
            item_date=self.Table_Sheets.item(i,cnum["Date"][0])
            if item_date.text()!="N/A":
                item_date.setText(self.measure_Date)

        
    def fill_fields(self):
        cnum=Ui_MainWindow.column_names
        self.GPX_filled=0
        i=0
        #print("row count:", self.Table_Sheets.rowCount())
        while i < self.Table_Sheets.rowCount():
            item_hour=self.Table_Sheets.item(i,cnum["Time"][0])
            if item_hour.text()!="":                
                m_hour=item_hour.text()
                try:
                    if len(m_hour)==5:
                        m_hour_format="%H:%M"
                        #print("format 5",m_hour)
                    else:
                        m_hour_format="%H:%M:%S"
                        #print("format 8",m_hour)
                    m_hour_time=datetime.datetime.strptime(m_hour,m_hour_format)
                except:
                    #print("some cells in column Time are not with the proper format (HH:MM or HH:MM:SS)")
                    Message_popup("Error","Error Value","some cells in column Time are not with the proper format (HH:MM or HH:MM:SS)")                   
                    self.GPX_filled=0
                    break
                m_hour=m_hour_time.strftime("%H:%M:%S")
                #print("passed!!. m_hour={} and len={}".format(m_hour,len(m_hour)))
                
                GPX=self.Table_Sheets.item(i,cnum["GPX"][0])

                direcc=[("backward",-1),("forward",1)]
                if i==0:
                    direcc=[("forward",1)]
                j=i
                for d,j_inc in direcc:
                    j+=j_inc
                    GPX1=self.Table_Sheets.item(j,cnum["GPX"][0])
                    while GPX1.text()==GPX.text():
                        self.Table_Sheets.item(j,cnum["Time"][0]).setText(m_hour)
                        j+=j_inc
                        if j<self.Table_Sheets.rowCount():
                            GPX1=self.Table_Sheets.item(j,cnum["GPX"][0])
                        else:
                            break
                #n_filled_cells+=1 #"number of GPX written
                self.GPX_filled+=1
                self.Label3_GPX.setText("GPX samples filled: {}".format(self.GPX_filled))
                i=j
                #print("this is another i:",i)
            else:
                i+=1
                #print("this is i:",i)
        
        if self.GPX_filled==0:
            Message_popup("Error","Error Value","The column Time is empty or some cells are not with the proper format (HH:MM or HH:MM:SS). No HH:MM found at any row")
            return "Error"
        
        return "OK"
            
    
    def read_table(self):

        ff=self.fill_fields()
        if ff=="Error":
            return "Error in fill_fields function"
        
        cnum=Ui_MainWindow.column_names
        self.sh_dates={} #dictionary with the dates to return
        sh_table={}
        n_entries=0
        #the key is the time => dict["YYY-MM-DD HH:MM:SS"]. the kays must be sorted by the time
        #the value is a list. list[0]=GPX, list[1]=FR/CR, list[2]=sheet_name of R. (R is the repetition of the GC, X is the spa sample number, P is the point) 
        v=lambda k0,i0: self.Table_Sheets.item(i0,cnum[k0][0])
        sh_table={k:[v(k,i).text() for i in range(0,self.Table_Sheets.rowCount()) if v("Time",i).text()!="" and v("Time",i).text()!="N/A"] for k in cnum.keys()}
        n_entries=len(sh_table["Sheets"])

        # for k in cnum.keys():
        #     sh_table[k]=[]
        #     for i in range(0,self.Table_Sheets.rowCount()):
        #         v=self.Table_Sheets.item(i,cnum[k][0])
        #         tm=self.Table_Sheets.item(i,cnum["Time"][0])
        #         if tm.text()!="" and tm.text()!="N/A":
        #             sh_table[k].append(v.text())
        #             n_entries+=1

        
        if n_entries==0:
            Message_popup("Error","No entries","No entries found, please add some entries in the Time column")

        else:
            if np.any(np.array(sh_table["Date"])==""):
                gd=np.where(np.array(sh_table["Date"])=="")[0].tolist()
                gd=[sh_table["GPX"][d] for d in gd]
                print("Some cell in Date column was empty. check cells of GPX={}".format(gd))#" {},{}".format(d+1,cnum["Date"][0]+1))
                Message_popup("Error","Empty Date cell","Some cell in Date column was empty. check cells of GPX={}".format(gd))
               
            else:
                sh_table1=pd.DataFrame.from_dict(sh_table)
                sh_table2=sh_table1.sort_values(by=["Time","GPX","BialR"],ascending=[True,True,False])
                temp="start"
                for index,row in sh_table2.iterrows():
                    if row["Time"]!=temp: #this is done to make that the first element be also a list as will be the others
                        self.sh_dates["{} {}".format(row["Date"],row["Time"])]=[[row["GPX"],row["BialR"],row["Sheets"]]]
                    else:
                        self.sh_dates["{} {}".format(row["Date"],row["Time"])].append([row["GPX"],row["BialR"],row["Sheets"]]) #each element is a list
                    temp=row["Time"] #this is done to make that the first element be also a list as the others
                Message_popup("Info","Done","Table succesfully read")
        
        self.cancel_window()

    def cancel_window(self):
        self.finish_window=True
        self.MainWindow.close()
        #sys.exit(app.exec_())
        #self.centralwidget.close()
            
    # def add_project_ok(self):
    #     global P
    #     P={}
    #     P[0]=Project("Proj1","This is the test project 1")
    
class Message_popup:
    def __init__(self,m_type,m_title="",m_text=""):
        self.msg=QMessageBox()
        self.msg.setWindowTitle(m_title)
        self.msg.setText(m_text)
        self.response="No"
        if m_type=="Error":
            self.msgError()            
        elif m_type=="Warning":
            self.msgWarning()
        elif m_type=="Info":
            self.msgInfo()         
        elif m_type=="YesorNo":
            self.msgYesNo()
        
    def msgError(self):
        self.msg.setIcon(QMessageBox.Critical)
        return self.msg.exec_()
    def msgWarning(self):
        self.msg.setIcon(QMessageBox.Warning)
        return self.msg.exec_()
    def msgInfo(self): 
        self.msg.setIcon(QMessageBox.Information)
        return self.msg.exec_()       
    def msgYesNo(self): 
        self.msg.setIcon(QMessageBox.Question)
        self.msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        self.msg.buttonClicked.connect(self.button_selected)
        #self.msg.standardButton()
        return self.msg.exec_()    

    def button_selected(self,i):
        if i.text()=="&Yes":
            self.response="Yes"
        else:
            self.response="No"
    
#if __name__ == "__main__":
# import sys
# table_sh={}
#app = QtWidgets.QApplication(sys.argv)
# MainWindow = QtWidgets.QMainWindow()
# ui = Ui_MainWindow()
# ui.setupUi(MainWindow)
# #MainWindow.show()
#     #sys.exit(app.exec_())

# filename="430_190201_G_190123.xls"
# ui.read_file(filename)
# #table_sh=ui.read_table()

# MainWindow.show()